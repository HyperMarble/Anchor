## Anchor v0 — 

### Status

* **Product version:** v1.0 (first public release)
* **Engine maturity:** v0 (foundational, constrained)
* **Scope:** Monorepo, single language, local only

---

## 1. Purpose of v0

Anchor v0 exists to prove **one thing only**:

> **An AI agent can safely read and write a real codebase without guessing file structure or breaking builds.**

Everything else is out of scope.

---

## 2. Explicit Non-Goals (v0)

Anchor v0 will **NOT** attempt to:

* Support multiple languages
* Support cross-repo linking
* Handle dynamic imports / reflection
* Understand runtime behavior
* Perform agent reasoning
* Optimize for sub-10ms latency
* Replace IDEs or agents

If it doesn’t help **safe context + safe edits**, it does not belong in v0.

---

## 3. Supported Environment (Hard Constraints)

### Repository

* **Monorepo only**
* Single root
* No sub-repo linking
* No workspace federation

### Language

* **One language only** (pick one at build time)

  * Recommended: **Rust** or **TypeScript**
* No polyglot parsing

### Execution

* Local machine
* Background daemon
* No cloud
* No remote state

---

## 4. Core Responsibilities (v0)

Anchor v0 has exactly **four responsibilities**:

1. Build a **deterministic structural graph**
2. Keep that graph **correct over time**
3. Answer **context queries** from agents
4. Perform **safe file writes**

Nothing more.

---

## 5. Architecture Overview

```
┌─────────────┐
│ AI Agent    │  (Claude / Cursor)
│ (Brain)     │
└─────┬───────┘
      │ MCP (JSON-RPC)
┌─────▼───────┐
│ Anchor      │
│ Daemon      │
│ (Body)      │
├─────────────┤
│ Graph       │  ← deterministic structure
│ AST Engine  │
│ File I/O    │
└─────────────┘
```

---

## 6. Tech Stack (v0)

### Language

* **Rust**

### Parsing

* `ast-grep-core`

  * Extract:

    * symbol definitions
    * references
    * imports / calls

### Config / Build Parsing

* **Minimal**
* Only language-native build files

  * e.g. `Cargo.toml` (Rust)
* No Docker, CI, infra in v0

### Graph

* `petgraph`
* Directed graph (DAG where possible)

### Identity

* `string-interner`

  * All symbol names interned
  * Graph nodes reference IDs, not strings

### Concurrency

* `rayon`
* Used **only during initial scan**

### Persistence

* `rkyv`
* Serialize graph to disk (`.anchor/db.bin`)

### File Watching

* `notify`
* Invalidate + recompute on change

### File Writes

* `atomic-write`
* Anchor is the **only writer**

### Protocol

* `mcp_rust_sdk`
* JSON-RPC only

---

## 7. The Graph Model (v0)

### Node Types

| Node   | Description                 |
| ------ | --------------------------- |
| File   | A source file               |
| Symbol | Function / struct / class   |
| Module | Language module / namespace |

### Edge Types

| Edge       | Meaning         |
| ---------- | --------------- |
| DEFINES    | File → Symbol   |
| REFERENCES | Symbol → Symbol |
| IMPORTS    | File → File     |

No conditional edges in v0.
No runtime semantics.

---

## 8. Determinism Rules (v0)

Anchor v0 **only claims what it can prove**.

### Allowed Truths

* Static imports
* Static symbol references
* File ownership

### Explicitly Unsupported

* Reflection
* Dynamic imports
* Runtime config
* Macros (unless trivially resolvable)

When unsupported:

* Anchor returns `"unknown"`
* Never guesses

---

## 9. Startup Flow (v0)

1. Daemon starts
2. Check for `.anchor/db.bin`
3. If missing:

   * Scan all source files
   * Parse ASTs via `ast-grep`
   * Build graph
   * Serialize graph to disk
4. Load graph into memory
5. Start MCP server
6. Start file watcher

Cold start may take seconds. This is acceptable.

---

## 10. Incremental Update Flow

On file change:

1. Identify changed file
2. Remove **all graph edges originating from that file**
3. Re-parse file AST
4. Re-insert edges
5. Persist updated graph

No partial invalidation.
Delete-then-rebuild per file.

---

## 11. Agent Read APIs (v0)

### `anchor_find_context`

**Purpose:**
Answer “where is this defined and used?”

**Input**

```json
{ "symbol": "login" }
```

**Output**

```json
{
  "definition": "auth.rs",
  "references": ["main.rs", "routes.rs"],
  "confidence": "high"
}
```

---

### `anchor_dependencies`

**Purpose:**
Answer “what depends on this file or symbol?”

---

## 12. Agent Write APIs (v0)

### Delegated Write — Refactor

#### `anchor_refactor_rename`

* Agent supplies:

  * symbol name
  * new name
* Anchor:

  * finds all occurrences
  * rewrites via AST
  * writes files atomically

Agent never sends code text.

---

### Direct Write — CodeGen / Fix

#### `anchor_apply_patch`

* Agent supplies:

  * file
  * code snippet
* Anchor:

  * finds insertion point structurally
  * applies safely
  * preserves formatting

Anchor **never modifies logic**.

---

## 13. Error Handling Philosophy

Anchor v0 prefers:

* ❌ refusing
* ❌ returning `"unknown"`

over:

* ❌ guessing
* ❌ partial truth

Incorrect confidence is the worst failure mode.

---

## 14. What Makes v0 “Done”

v0 is complete when:

* An agent can:

  * ask “where is X?”
  * rename a symbol safely
  * insert code without breaking syntax
* The graph survives restarts
* File changes update graph correctly
* No cross-repo logic exists
